# Blog Service

[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)

# gitlab.com/Nikolay-Yakunin/blog-service/

## Цель проекта

Создать масштабируемый и модульный блог-сервис, обеспечивающий:

- Редактирование и форматирование контента с помощью Markdown.
- Интерактивность постов с возможностью голосования и оценки.
- Надёжную аутентификацию через популярные OAuth-провайдеры.
- Управление комментариями с иерархической структурой.
- Дополнительные функции, такие как поиск, уведомления и административная панель.
- Лёгкую контейнеризацию, автоматизированную сборку и мониторинг.

# Предметная область

Личный блог, посты сохраняемые в формате md, средства аутентификации с помощью провайдеров, комментарии, быстрый поиск по постам (названиям, контенту постов, комментариям, веткам комментариев), уведомления и админ панель с метриками, аналитикой и инструментами модерации, администрирования.

# Бизнес процессы

- Посты
  - Создание, редактирование, удаление, теги, отложенная публикация, счетчик просмотров, оценка, интерактивности (голосование или сбор обратной связи)
- Пользователи
  - Аутентификация через провайдера, редактирование информации профиля, верификация для повышения доступа (не верифицированные пользователи, могут только просматривать посты)
- Комментарии
  - Ответ на комментарий (ветвление, thread), верификация доступа, цензура по черному списку (слова с которыми комментарий не может быть создан, например "\*\*\*")
- Быстрый поиск
  - Поиск по тегам, поиск по заголовкам, поиск по контенту, поиск по верхнему уровню комментариев, поиск по веткам комментариев
- Уведомления
  - Уведомления и оповещения внутри сервиса (я хочу купить домен, но у меня денег нет, а stmp не зарегать без домена)
- Метрики и аналитика
  - Анализ посещаемости, просмотров, удержания на посте (авторизованных, неавторизованных, верифицированных пользователей), количества аутентификаций (по провайдерам), количества новых пользователей (авторизованных), количества комментариев (для верифицированных пользователей)

## Сборка

1. Клонирование репозитория
   по _http_

```
git clone https://gitlab.com/Nikolay-Yakunin/blog-service.git
```

или по _ssh_

```
git clone git@gitlab.com:Nikolay-Yakunin/blog-service.git
```

PS: для генерации ключа

```
ssh-keygen -t rsa
cat (имя файла с ключем | по дефолту /root/.ssh/id_rsa)
```

Скопируйте оутпут и добавьте в свой профиль Gitlab/Github

# Requerments

Перед началом сборки проекта, убедитесь, что у вас присутствуют все необходимые зависимости

- **Go**: 1.24.1
- **Make**: для локальной сборки проекта
- **Docker** and **Docker-compose**: для сборки контейнера
- **Postgress**: 17 база данных
- **[golang-migrate/migrate CLI](https://github.com/golang-migrate/migrate)**: для управления миграциями базы данных. Устанавливается автоматически при первом запуске команд `make migrate-*` или вручную:
  ```bash
  go install -tags 'postgres' github.com/golang-migrate/migrate/v4/cmd/migrate@latest
  ```

# Сборка с помощью Make

```
make
```

На выходе у вас будет исполняемый файл с именем **main** или **main.exe**, в зависимости от платформы

## Локальный запуск приложения

1. Настройка локальной базы данных:

   - Убедитесь, что у вас установлен и запущен PostgreSQL
   - Создайте базу данных:
     ```sql
     CREATE DATABASE blog_service;
     ```

2. Настройка переменных окружения:

   ```bash
   # Создайте файл .env.local на основе шаблона
   cp .env.example .env.local

   # Отредактируйте .env.local, указав адрес локальной БД
   # DATABASE_URL=postgres://postgres:postgres@localhost:5432/blog_service?sslmode=disable
   ```

3. Запустите приложение в локальном режиме:

   ```bash
   APP_ENV=local go run cmd/blog-service/main.go
   ```

4. Приложение будет доступно по адресу: http://localhost:8080

## Новые возможности аутентификации

В проект добавлена система аутентификации с использованием JWT и OAuth:

- Аутентификация через OAuth (GitHub, Google, VK)
- JWT токены для авторизации
- RESTful API для управления пользователями
- Поддержка различных ролей пользователей

### API эндпоинты аутентификации

#### Аутентификация

- `GET /api/v1/auth/login/:provider` - Начать OAuth аутентификацию (provider: github, google, vk)
- `GET /api/v1/auth/callback/:provider` - Callback для OAuth провайдера
- `POST /api/v1/auth/logout` - Выход из системы (требует JWT токен)

#### Пользователи

- `GET /api/v1/users/:id` - Получить информацию о пользователе
- `GET /api/v1/users/me` - Получить информацию о текущем пользователе (требует JWT токен)
- `PUT /api/v1/users/me` - Обновить информацию о текущем пользователе (требует JWT токен)

#### Административные

- `GET /api/v1/users/admin?role=:role` - Список пользователей по роли (admin, moderator)
- `PUT /api/v1/users/admin/:id/verify` - Верифицировать пользователя (admin, moderator)
- `PUT /api/v1/users/admin/:id/role` - Изменить роль пользователя (admin)
- `PUT /api/v1/users/admin/:id/deactivate` - Деактивировать пользователя (admin)

## Структура проекта

```
.
├── cmd/
│   └── app/                 # Точка входа приложения
├── config/                  # Конфигурационные файлы
├── internal/
│   ├── posts/               # Управление постами
│   ├── users/               # Управление пользователями
│   ├── auth/                # Аутентификация через OAuth
│   ├── comments/            # Система комментариев
│   ├── search/              # Поисковый движок
│   ├── notifications/       # Система уведомлений
│   ├── admin/               # Административная панель
│   └── metrics/             # Сбор и анализ метрик
├── pkg/
│   ├── database/            # Работа с БД
│   ├── middleware/          # Промежуточные обработчики
│   ├── validator/           # Валидация данных
│   ├── auth/                # Компоненты аутентификации
│   │   ├── jwt/             # Работа с JWT
│   │   └── oauth/           # Работа с OAuth
│   └── utils/               # Общие утилиты
├── migrations/              # SQL миграции
├── docs/                    # Документация API
└── deployments/             # Конфигурации развертывания
    ├── docker/
    └── kubernetes/          # Возможно
```

## Swagger Documentation

Документация API доступна через Swagger UI после запуска приложения:

```bash
# Локальный доступ к Swagger UI
http://localhost:8080/swagger/index.html

# Генерация документации Swagger
make swagger
```

### Требования для Swagger

- swag CLI tool: `go install github.com/swaggo/swag/cmd/swag@latest`
- gin-swagger middleware: `github.com/swaggo/gin-swagger`

## OAuth Configuration

Для работы OAuth аутентификации необходимо создать приложения у провайдеров и настроить переменные окружения:

### GitHub OAuth

```bash
OAUTH_GITHUB_CLIENT_ID=your_client_id
OAUTH_GITHUB_CLIENT_SECRET=your_client_secret
OAUTH_GITHUB_REDIRECT_URL=http://localhost:8080/api/v1/auth/callback/github
```

### Google OAuth

```bash
OAUTH_GOOGLE_CLIENT_ID=your_client_id
OAUTH_GOOGLE_CLIENT_SECRET=your_client_secret
OAUTH_GOOGLE_REDIRECT_URL=http://localhost:8080/api/v1/auth/callback/google
```

### VK OAuth

```bash
OAUTH_VK_CLIENT_ID=your_client_id
OAUTH_VK_CLIENT_SECRET=your_client_secret
OAUTH_VK_REDIRECT_URL=http://localhost:8080/api/v1/auth/callback/vk
```

## Компоненты инфраструктуры

- **PostgreSQL**: Основное хранилище данных
- **Redis**: Кеширование и сессии
- **Elasticsearch**: Поисковый движок
- **Prometheus + Grafana**: Мониторинг и визуализация метрик
- **Docker**: Контейнеризация
- **Nginx**: Обратный прокси-сервер

## Миграции базы данных

Миграции схемы базы данных находятся в папке `/migrations` и управляются с помощью `golang-migrate/migrate` через Makefile.

Перед первым запуском приложения или после получения изменений, связанных со схемой БД, необходимо применить миграции:

```bash
# Убедитесь, что PostgreSQL запущен (локально или в Docker)
# и переменная DATABASE_URL в файле .env указывает на него.

# Применить все новые миграции:
make migrate-up
```

Другие команды для управления миграциями:

```bash
# Откатить последнюю примененную миграцию:
make migrate-down

# Откатить все миграции (осторожно!):
make migrate-down-all

# Создать новые файлы для следующей миграции (вам будет предложено ввести имя):
make migrate-create

# Проверить текущую версию схемы БД:
make migrate-status
```

**Важно:** При запуске через `docker-compose` миграции **не применяются автоматически** по умолчанию. Вам нужно либо запустить `make migrate-up` перед `make docker-up`, либо настроить автоматическое применение миграций при старте контейнера `api` (см. рекомендации по улучшению).

## Команды Makefile

- **make build**: Сборка приложения.
- **make test**: Запуск тестов с генерацией отчёта покрытия.
- **make docker-up**: Запуск приложения через docker-compose.
- **make clean**: Очистка сгенерированных файлов.
- **make swagger**: Генерация документации Swagger.
- **make migrate-up**: Применить миграции базы данных.
- **make migrate-down**: Откатить последнюю миграцию.
- **make migrate-create**: Создать файлы для новой миграции.
- **make migrate-status**: Показать статус миграций.

## Развертывание с Docker

1. Настройка переменных окружения:

```bash
cp .env.example .env
# Отредактируйте .env файл с вашими настройками
```

2. Сборка и запуск всех сервисов:

```bash
docker-compose up -d
```

3. Проверка статуса:

```bash
docker-compose ps
```

4. Просмотр логов:

```bash
docker-compose logs -f api
```

5. Остановка:

```bash
docker-compose down
```

Сервисы будут доступны по следующим портам:

- Blog API: http://localhost:8080
- Grafana: http://localhost:3000
